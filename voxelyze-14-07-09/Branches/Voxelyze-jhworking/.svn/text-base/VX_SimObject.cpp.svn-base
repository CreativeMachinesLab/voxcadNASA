/*******************************************************************************
Copyright (c) 2010, Jonathan Hiller (Cornell University)
If used in publication cite "J. Hiller and H. Lipson "Dynamic Simulation of Soft Heterogeneous Objects" In press. (2011)"

This file is part of Voxelyze.
Voxelyze is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
Voxelyze is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.
See <http://www.opensource.org/licenses/lgpl-3.0.html> for license details.
*******************************************************************************/

#include "VX_SimObject.h"
//#include "VXS_Voxel.h"
//#include "VXS_Bond.h"
#include "Utils/MarchCube.h"


CVX_SimObject::CVX_SimObject(void)
{

	pEnv = NULL;
	MeshAutoGenerated=true;


	ClearAll();
}

CVX_SimObject::~CVX_SimObject(void)
{
	ClearAll();

//	delete VoxelInput;
//	delete BondInput;
//	out.close();
}

CVX_SimObject& CVX_SimObject::operator=(const CVX_Sim& rSim) //overload "=" 
{
	//TODO: set everything sensible equal.

	return *this;
}

void CVX_SimObject::SaveVXAFile(std::string filename)
{
	CXML_Rip XML;
	WriteVXA(&XML);
	XML.SaveFile(filename);
}

bool CVX_SimObject::LoadVXAFile(std::string filename, std::string* pRetMsg)
{
	CXML_Rip XML;
	if (!XML.LoadFile(filename, pRetMsg)) return false;
	ReadVXA(&XML, pRetMsg);
	return true;
}

void CVX_SimObject::WriteVXA(CXML_Rip* pXML)
{
	pXML->DownLevel("VXA");
	pXML->SetElAttribute("Version", "1.1");
	WriteXML(pXML);
	pEnv->WriteXML(pXML);
	pEnv->pObj->WriteXML(pXML);
	pXML->UpLevel();
}

bool CVX_SimObject::ReadVXA(CXML_Rip* pXML, std::string* RetMessage) //pointer to VXA element
{
//	pObj->ClearMatter();
	std::string ThisVersion = "1.1";
	std::string Version;
	pXML->GetElAttribute("Version", &Version);
	if (atof(Version.c_str()) > atof(ThisVersion.c_str())) if (RetMessage) *RetMessage += "Attempting to open newer version of VXA file. Results may be unpredictable.\nUpgrade to newest version of VoxCAD.\n";

	if (pXML->FindElement("Simulator")){
		ReadXML(pXML);
		pXML->UpLevel();
	}

	//load environment
	if (pEnv && pXML->FindElement("Environment")){
		pEnv->ReadXML(pXML);
		pXML->UpLevel();
	}

	//Load VXC if pObj is valid...
	if (pEnv->pObj && (pXML->FindElement("VXC") || pXML->FindElement("DMF"))){
		pEnv->pObj->ReadXML(pXML, false, RetMessage);
		pXML->UpLevel();
	}
	return true;
}

void CVX_SimObject::WriteXML(CXML_Rip* pXML)
{
	pXML->DownLevel("Simulator");
		pXML->DownLevel("Integration");
		pXML->Element("Integrator", 0); //0 = euler in older versions
		pXML->Element("DtFrac", DtFrac);
		pXML->UpLevel();

		pXML->DownLevel("Damping");
		pXML->Element("BondDampingZ", BondDampingZ);
		pXML->Element("ColDampingZ", ColDampingZ);
		pXML->Element("SlowDampingZ", SlowDampingZ);
		pXML->UpLevel();

		pXML->DownLevel("Collisions");
		pXML->Element("SelfColEnabled", IsFeatureEnabled(VXSFEAT_COLLISIONS));
		pXML->Element("ColSystem", CurColSystem);
		pXML->Element("CollisionHorizon", CollisionHorizon);
		pXML->UpLevel();

		pXML->DownLevel("Features");
		pXML->Element("MaxVelLimitEnabled", IsFeatureEnabled(VXSFEAT_MAX_VELOCITY));
		pXML->Element("MaxVoxVelLimit", MaxVoxVelLimit);
		pXML->Element("BlendingEnabled", IsFeatureEnabled(VXSFEAT_BLENDING));
		pXML->Element("MixRadius", MixRadius);
		pXML->Element("BlendModel", BlendModel);
		pXML->Element("PolyExp", PolyExp);
//		pXML->Element("FluidDampEnabled", IsFeatureEnabled(VXSFEAT_));
		pXML->Element("VolumeEffectsEnabled", IsFeatureEnabled(VXSFEAT_VOLUME_EFFECTS));
//		pXML->Element("EnforceLatticeEnabled", IsFeatureEnabled(VXSFEAT_));
		pXML->UpLevel();

		pXML->DownLevel("StopCondition");
		pXML->Element("StopConditionType", (int)StopConditionType);
		pXML->Element("StopConditionValue", StopConditionValue);
		pXML->UpLevel();

		pXML->DownLevel("EquilibriumMode");
		pXML->Element("EquilibriumModeEnabled", IsFeatureEnabled(VXSFEAT_EQUILIBRIUM_MODE));
	//	pXML->Element("StopConditionValue", StopConditionValue);
		pXML->UpLevel();

		if (!MeshAutoGenerated){
			pXML->DownLevel("SurfMesh");
			SurfMesh.DefMesh.WriteXML(pXML, true);
			pXML->UpLevel();
		}

		WriteAdditionalSimXML(pXML);
	pXML->UpLevel();

}

bool CVX_SimObject::ReadXML(CXML_Rip* pXML, std::string* RetMessage)
{
	int tmpInt;
	vfloat tmpVFloat;
	bool tmpBool;

	if (pXML->FindElement("Integration")){
//		if (pXML->FindLoadElement("Integrator", &tmpInt)) CurIntegrator = (IntegrationType)tmpInt; else CurIntegrator = I_EULER;
		if (!pXML->FindLoadElement("DtFrac", &DtFrac)) DtFrac = (vfloat)0.9;
		pXML->UpLevel();
	}
		
	if (pXML->FindElement("Damping")){
		if (!pXML->FindLoadElement("BondDampingZ", &BondDampingZ)) BondDampingZ = 0.1;
		if (!pXML->FindLoadElement("ColDampingZ", &ColDampingZ)) ColDampingZ = 1.0;
		if (!pXML->FindLoadElement("SlowDampingZ", &SlowDampingZ)) SlowDampingZ = 1.0;
		pXML->UpLevel();
	}

	if (pXML->FindElement("Collisions")){
		if (!pXML->FindLoadElement("SelfColEnabled", &tmpBool)) tmpBool=false; EnableFeature(VXSFEAT_COLLISIONS, tmpBool);
		if (pXML->FindLoadElement("ColSystem", &tmpInt)) CurColSystem = (ColSystem)tmpInt; else CurColSystem = COL_SURFACE_HORIZON;
		if (!pXML->FindLoadElement("CollisionHorizon", &CollisionHorizon)) CollisionHorizon = (vfloat)2.0;
		pXML->UpLevel();
	}

	if (pXML->FindElement("Features")){
		if (!pXML->FindLoadElement("MaxVelLimitEnabled", &tmpBool)) tmpBool = false; EnableFeature(VXSFEAT_MAX_VELOCITY, tmpBool);
		if (!pXML->FindLoadElement("MaxVoxVelLimit", &MaxVoxVelLimit)) MaxVoxVelLimit = (vfloat)0.1;
		if (!pXML->FindLoadElement("BlendingEnabled", &tmpBool)) tmpBool = false; EnableFeature(VXSFEAT_BLENDING, tmpBool);
		if (!pXML->FindLoadElement("MixRadius", &MixRadius)) MixRadius = 0.0;
		if (pXML->FindLoadElement("BlendModel", &tmpInt)) BlendModel = (MatBlendModel)tmpInt; else BlendModel = MB_LINEAR;
		if (!pXML->FindLoadElement("PolyExp", &PolyExp)) PolyExp = 1.0;

		if (!pXML->FindLoadElement("FluidDampEnabled", &tmpBool)) tmpBool = false; //do nothing for now...
		if (!pXML->FindLoadElement("VolumeEffectsEnabled", &tmpBool)) tmpBool = false; EnableFeature(VXSFEAT_VOLUME_EFFECTS, tmpBool);
		if (!pXML->FindLoadElement("EnforceLatticeEnabled", &tmpBool)) tmpBool = false;  //do nothing for now...
		pXML->UpLevel();
	}

	if (pXML->FindElement("StopCondition")){
		if (pXML->FindLoadElement("StopConditionType", &tmpInt)) SetStopConditionType((StopCondition)tmpInt); else SetStopConditionType();
		if (pXML->FindLoadElement("StopConditionValue", &tmpVFloat)) SetStopConditionValue(tmpVFloat); else SetStopConditionValue();
		pXML->UpLevel();
	}

	if (pXML->FindElement("EquilibriumMode")){
		if (!pXML->FindLoadElement("EquilibriumModeEnabled", &tmpBool)) tmpBool = false; if (tmpBool && !IsFeatureEnabled(VXSFEAT_EQUILIBRIUM_MODE)) EnableFeature(VXSFEAT_EQUILIBRIUM_MODE, true);
		//if (EquilibriumModeEnabled) EnableEquilibriumMode(true); //so it can set up energy history if necessary
		pXML->UpLevel();
	}
	
	MeshAutoGenerated=true;
	if (pXML->FindElement("SurfMesh")){
		if (pXML->FindElement("CMesh")){
			MeshAutoGenerated=false;
			SurfMesh.DefMesh.ReadXML(pXML);
			pXML->UpLevel();
		}
		pXML->UpLevel();
	}

	return ReadAdditionalSimXML(pXML, RetMessage);
}


void CVX_SimObject::ClearAll(void) //Reset all initialized variables
{
	Initalized = false;
	LocalVXC.ClearMatter();

	//This should be all the stuff set by "Import()"
	VoxArray.clear();
	BondArrayInternal.clear();
	XtoSIndexMap.clear();
	StoXIndexMap.clear();
	SurfVoxels.clear();

	MaxDispSinceLastBondUpdate = (vfloat)FLT_MAX; //arbitrarily high as a flag to populate bonds

	ClearHistories();

	dt = (vfloat)0.0; //calculated per-step
	CurTime = (vfloat)0.0;
	CurStepCount = 0;
	DtFrozen = false;

	SS.Clear();
	IniCM = Vec3D<>(0,0,0);

	SurfMesh.Clear();
	MeshAutoGenerated=true;
}


bool CVX_SimObject::UpdateVoxPointers() //updates all pointers into the VoxArray (call if reallocated!)
{
	//internal bonds
	for (std::vector<CVXS_BondInternal>::iterator it = BondArrayInternal.begin(); it != BondArrayInternal.end(); it++){
		if (!it->UpdateVoxelPtrs()) return false;
	}
	return true;
}


void CVX_SimObject::UpdateInternalBondPointers() //updates all pointers into the VoxArray (call if reallocated!)
{
	//Todo: evaluate if this is needed anymore?
	for (std::vector<CVXS_Voxel>::iterator it = VoxArray.begin(); it != VoxArray.end(); it++){
//		if (!it->UpdateBondLinks()) return false;
		it->UpdateInternalBondPtrs();
	}
}

/*! The environment should have been previously initialized and linked with a single voxel object. 
This function sets or resets the entire simulation with the new environment.
@param[in] pEnvIn A pointer to initialized CVX_Environment to import into the simulator.
@param[out] RetMessage A pointer to initialized string. Output information from the Import function is appended to this string.
*/
bool CVX_SimObject::Import_VXObject(CVX_Environment* pEnvIn, CMesh* pSurfMeshIn, std::string* RetMessage)
{
	ClearAll(); //clears out all arrays and stuff

	if (pEnvIn != NULL) pEnv = pEnvIn;
	if (pEnv == NULL) {if (RetMessage) *RetMessage += "Invalid Environment pointer"; return false;}

	//get in sync with environment options
	EnableFeature(VXSFEAT_GRAVITY, pEnv->IsGravityEnabled());
	EnableFeature(VXSFEAT_FLOOR, pEnv->IsFloorEnabled());
	EnableFeature(VXSFEAT_TEMPERATURE, pEnv->IsTempEnabled());
	EnableFeature(VXSFEAT_TEMPERATURE_VARY, pEnv->IsTempVaryEnabled());

	LocalVXC = *pEnv->pObj; //make a copy of the reference digital object!
	if (LocalVXC.GetNumVox() == 0) {if (RetMessage) *RetMessage += "No voxels in object"; return false;}

	int SIndexIt = 0; //keep track of how many voxel we've added (for storing reverse lookup array...)
	int NumBCs = pEnv->GetNumBCs();
	CVX_FRegion* pCurBc;


	//initialize XtoSIndexMap & StoXIndexMap
	XtoSIndexMap.resize(LocalVXC.GetStArraySize(), -1); // = new int[LocalVXC.GetStArraySize()];
	StoXIndexMap.resize(LocalVXC.GetNumVox(), -1); // = new int [m_NumVox];


	std::vector<int> Sizes(NumBCs, 0);
	for (int i=0; i<NumBCs; i++) Sizes[i] = pEnv->GetNumTouching(i);
//	pEnv->GetNumVoxTouchingForced(&Sizes); //get the number of voxels in each region (to apply equal force to each voxel within this region!)

//	Vec3D BCpoint;
	Vec3D<> BCsize = pEnv->pObj->GetLatDimEnv()/2.0;
	Vec3D<> WSSize = pEnv->pObj->GetWorkSpace();

	//Add all Voxels:
	bool HasPlasticMaterial = false;
	Vec3D<> ThisPos;
	vfloat ThisScale = LocalVXC.GetLatDimEnv().x; //force to cubic
	//Build voxel list
	for (int i=0; i<LocalVXC.GetStArraySize(); i++){ //for each voxel in the array
		XtoSIndexMap[i] = -1; //assume there is not a voxel here...

		if(LocalVXC.Structure[i] != 0 ){ //if there's material here
			int ThisMatIndex = LocalVXC.GetLeafMatIndex(i); 
			int ThisMatModel = LocalVXC.Palette[ThisMatIndex].GetMatModel();
			if (ThisMatModel == MDL_BILINEAR || ThisMatModel == MDL_DATA) HasPlasticMaterial = true; //enable plasticity in the sim

			LocalVXC.GetXYZ(&ThisPos, i, false);//Get XYZ location

			CVXS_Voxel CurVox(this, SIndexIt, i, ThisMatIndex, ThisPos, ThisScale);

			XtoSIndexMap[i] = SIndexIt; //so we can find this voxel based on it's original index
			StoXIndexMap[SIndexIt] = i; //so we can find the original index based on its simulator position
			
			for (int j = 0; j<NumBCs; j++){ //go through each primitive defined as a constraint!
				pCurBc = pEnv->GetBC(j);
				if (pCurBc->GetRegion()->IsTouching(&ThisPos, &BCsize, &WSSize)){ //if this point is within
					CurVox.FixDof(pCurBc->DofFixed);
					CurVox.AddExternalForce(pCurBc->Force/Sizes[j]);
					CurVox.AddExternalTorque(pCurBc->Torque/Sizes[j]);
					CurVox.SetExternalDisp(pCurBc->Displace);
					CurVox.SetExternalTDisp(pCurBc->AngDisplace);
				}
			}

//			if(BlendingEnabled) CurVox.CalcMyBlendMix(); //needs to be done basically last. Todo next: move to constructor and ditch blendmix and even p_sim from voxel?
			VoxArray.push_back(CurVox);
			SIndexIt++;
		}
	}


	//add input voxel so that NumVox() works!
//	InputVoxSInd = (int)VoxArray.size();
//	CVXS_Voxel TmpVox(this, 0, 0, 0, Vec3D<>(0,0,0), 0);
//	TmpVox.LinkToVXSim(this);
//	VoxArray.push_back(TmpVox);


	//Set up all permanent bonds
	//Between adjacent voxels in the lattice
	int ThisX=0, ThisY=0, ThisZ=0, posXInd=0; //index of the nex voxel in positive directions
	std::string BondFailMsg = "At least one bond creation failed during import";
	for (int i=0; i<NumVox(); i++){ //for each voxel in our newly-made array look in the +X, +Y and +Z directions to form a bond
		LocalVXC.GetXYZNom(&ThisX, &ThisY, &ThisZ, StoXIndexMap[i]);

		for (int j=0; j<3; j++){ //for each positive direction in the lattice
			switch (j){ 
				case 0: posXInd = LocalVXC.GetIndex(ThisX+1, ThisY, ThisZ); break; //X
				case 1: posXInd = LocalVXC.GetIndex(ThisX, ThisY+1, ThisZ); break; //Y
				case 2: posXInd = LocalVXC.GetIndex(ThisX, ThisY, ThisZ+1); break; //Z
			}
			if (posXInd != -1 && LocalVXC.Structure[posXInd]) if(!CreatePermBond(i, XtoSIndexMap[posXInd]) && RetMessage) *RetMessage += BondFailMsg;
		}
	}

	//Create input bond
//	CreateBond(B_INPUT_LINEAR_NOROT, InputVoxSInd, InputVoxSInd, true, &InputBondInd, false); //create input bond, but initialize it to meaningless connection to self

	UpdateAllBondPointers(); //necessary since we probably reallocated the bond array when adding pbonds the first time

	//Set up our surface list...
	for (int i=0; i<NumVox(); i++){ //for each voxel in our newly-made array
		if (VoxArray[i].IsSurfaceVoxel()){
//		if (VoxArray[i].GetNumLocalBonds() != 6){
			SurfVoxels.push_back(i);
		}

		//todo: only do for those on surfaces, I think.
		VoxArray[i].CalcNearby(this, (int)(CollisionHorizon*1.5)); //populate the nearby array
	}




//ifdef USE_OPEN_GL
	VoxMesh.ImportLinkSim(this);
	VoxMesh.DefMesh.DrawSmooth = false;

	//if the input mesh is not valid, use marching cubes to create one
	if (!pSurfMeshIn){
		MeshAutoGenerated = true;
		CMesh GeneratedSmoothMesh;

		CArray3Df OccupancyArray(pEnv->pObj->GetVXDim(), pEnv->pObj->GetVYDim(), pEnv->pObj->GetVZDim()); 
		int NumPossibleVox = pEnv->pObj->GetStArraySize();
		for (int g=0; g<NumPossibleVox; g++){
			if (pEnv->pObj->Structure.GetData(g)>0) OccupancyArray[g] = 1.0;
		}
		CMarchCube::SingleMaterial(&GeneratedSmoothMesh, &OccupancyArray, 0.5, pEnv->pObj->GetLatticeDim());
		SurfMesh.ImportSimWithMesh(this, &GeneratedSmoothMesh);
	}
	else {
		MeshAutoGenerated=false;
		SurfMesh.ImportSimWithMesh(this, pSurfMeshIn);
	}

//#endif


	ResetSimulation();
	OptimalDt = CalcMaxDt(); //to set up dialogs parameter ranges, we need this before the first iteration.
	EnableFeature(VXSFEAT_PLASTICITY, HasPlasticMaterial);
//	EnablePlasticity(HasPlasticMaterial); //turn off plasticity if we don't need it...

	Initalized = true;
//	std::string tmpString;

	std::ostringstream os;
	os << "Completed Simulation Import: " << NumVox() << " Voxels, " << NumBond() << "Bonds.\n";
	*RetMessage += os.str();

	return true;
}

/*! This bond is appended to the master bond array (BondArrayInternal). 
The behavior of the bond is determined by BondType. If the bond is permanent and should persist throughout the simulation PermIn should be to true.
@param[in] BondTypeIn The physical behavior of the bond being added.
@param[in] SIndex1 One simulation voxel index to be joined.
@param[in] SIndex2 The other simulation voxel index to be joined.
@param[in] PermIn Denotes whether this bond should persist throughout the simulation (true) or is temporary (false).
*/
int CVX_SimObject::CreatePermBond(int SIndexNegIn, int SIndexPosIn) //take care of all allocation, etc.
{
	if(IS_ALL_FIXED(VoxArray[SIndexNegIn].GetDofFixed()) && IS_ALL_FIXED(VoxArray[SIndexPosIn].GetDofFixed())) return -1; //if both voxels are fixed don't bother making a bond. (unnecessary)

	CVXS_BondInternal tmp(this);
//	if (!tmp.DefineBond(B_LINEAR, SIndexNegIn, SIndexPosIn)) return -1;
	if (!tmp.LinkVoxels(SIndexNegIn, SIndexPosIn)) return -1;
	BondArrayInternal.push_back(tmp);
	int MyBondIndex = NumBond()-1;

	BondDir nVoxBD, pVoxBD;
	switch (BondArrayInternal.back().GetBondAxis()){
	case AXIS_X: nVoxBD=BD_PX; pVoxBD=BD_NX; break;
	case AXIS_Y: nVoxBD=BD_PY; pVoxBD=BD_NY; break;
	case AXIS_Z: nVoxBD=BD_PZ; pVoxBD=BD_NZ; break;
	case AXIS_NONE: BondArrayInternal.pop_back(); return -1; //fail. can only deal with bond aligned with an axis here.
	}

	VoxArray[SIndexNegIn].LinkInternalBond(MyBondIndex, nVoxBD);
	VoxArray[SIndexPosIn].LinkInternalBond(MyBondIndex, pVoxBD);

	return MyBondIndex;
}
